{
  "_args": [
    [
      {
        "raw": "synchd@^1.0.0",
        "scope": null,
        "escapedName": "synchd",
        "name": "synchd",
        "rawSpec": "^1.0.0",
        "spec": ">=1.0.0 <2.0.0",
        "type": "range"
      },
      "C:\\Users\\Developer\\Desktop\\sprout\\sprout_erp-master\\sprout_erp-master\\node_modules\\browserify-hmr"
    ]
  ],
  "_from": "synchd@>=1.0.0 <2.0.0",
  "_id": "synchd@1.0.2",
  "_inCache": true,
  "_location": "/synchd",
  "_nodeVersion": "6.6.0",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/synchd-1.0.2.tgz_1474067923840_0.17731118598021567"
  },
  "_npmUser": {
    "name": "agentme",
    "email": "agentme49@gmail.com"
  },
  "_npmVersion": "3.10.7",
  "_phantomChildren": {},
  "_requested": {
    "raw": "synchd@^1.0.0",
    "scope": null,
    "escapedName": "synchd",
    "name": "synchd",
    "rawSpec": "^1.0.0",
    "spec": ">=1.0.0 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/browserify-hmr"
  ],
  "_resolved": "https://registry.npmjs.org/synchd/-/synchd-1.0.2.tgz",
  "_shasum": "537962907e79e2d1007d9968e46f435a63c1d58e",
  "_shrinkwrap": null,
  "_spec": "synchd@^1.0.0",
  "_where": "C:\\Users\\Developer\\Desktop\\sprout\\sprout_erp-master\\sprout_erp-master\\node_modules\\browserify-hmr",
  "author": {
    "name": "Chris Cowan",
    "email": "agentme49@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/AgentME/synchd/issues"
  },
  "dependencies": {
    "babel-runtime": "^6.11.6"
  },
  "description": "Make guarded sections of code that won't run concurrently and queue instead",
  "devDependencies": {
    "babel-cli": "^6.14.0",
    "babel-eslint": "^6.1.2",
    "babel-plugin-transform-class-properties": "^6.11.5",
    "babel-plugin-transform-flow-strip-types": "^6.14.0",
    "babel-plugin-transform-runtime": "^6.15.0",
    "babel-preset-es2015": "^6.14.0",
    "babel-register": "^6.14.0",
    "eslint": "^3.5.0",
    "flow-bin": "^0.32.0",
    "flow-copy-source": "^1.1.0",
    "mocha": "^3.0.2",
    "pdelay": "^1.0.0",
    "semver": "^5.3.0",
    "sinon": "^1.17.5"
  },
  "directories": {},
  "dist": {
    "shasum": "537962907e79e2d1007d9968e46f435a63c1d58e",
    "tarball": "https://registry.npmjs.org/synchd/-/synchd-1.0.2.tgz"
  },
  "gitHead": "637d4296de7f16d6913ce6c5bef66f4690bd38fc",
  "homepage": "https://github.com/AgentME/synchd#readme",
  "keywords": [
    "mutex",
    "asynchronous",
    "queue",
    "promise"
  ],
  "license": "MIT",
  "main": "js/index.js",
  "maintainers": [
    {
      "name": "agentme",
      "email": "agentme49@gmail.com"
    }
  ],
  "name": "synchd",
  "optionalDependencies": {},
  "readme": "# synchd\n\n[![Circle CI](https://circleci.com/gh/AgentME/synchd.svg?style=shield)](https://circleci.com/gh/AgentME/synchd)\n[![npm version](https://badge.fury.io/js/synchd.svg)](https://badge.fury.io/js/synchd)\n\nThis module allows guarded sections of code to be made that execute exclusively\nin the order they're called.\n\nSimilar to [node-synchronized](https://github.com/jupiter/node-synchronized),\nbut uses Promises and includes Flow type declarations.\n\n## API\n\nThis project exports the `synchd` and `synchdFn` functions. If you're using an\nES6 compiler, you can access them like this:\n\n```js\nimport {synchd, synchdFn} from 'synchd';\n```\n\nOr you can access the functions through the classic CommonJS style:\n\n```js\nvar synchd = require('synchd');\n// synchd.synchd(...)\n// synchd.synchdFn(...)\n```\n\n### synchd(scopeKey, fn)\n\n`scopeKey` may be any object and it's used as the lock. No other synchd calls\nwith the same scopeKey given will be run at the same time; they will be queued\nin-order to run after. `fn` is a function which takes no arguments and must\nreturn a Promise.\n\nThis call returns a Promise that resolves to the same value that the Promise\nreturned by `fn` resolves to.\n\n### synchdFn(scopeKey, fn)\n\nThis is a convenience function for creating functions that are entirely wrapped\nin a synchd call with a single scopeKey.\n\n`scopeKey` has the same meaning as above. `fn` is a function that may take\narguments and must return a Promise.\n\nThis call returns a function with the same signature as `fn`. All arguments\npassed to the function will be passed on to `fn` when it gets executed, and the\nreturned Promise will resolve to the value of the Promise that `fn` returns.\n\nHere's an example of defining a single function which can't be running multiple\ntimes concurrently. This example assumes you're using a compiler which supports\nasync/await.\n\n```js\nimport {synchdFn} from 'synchd';\nimport delay from 'pdelay';\n\nconst exclusiveFunction = synchdFn({}, async (x) => {\n  console.log(`exclusiveFunction(${x}) started`);\n  await delay(100);\n  console.log(`exclusiveFunction(${x}) ending`);\n  return x+1;\n});\n\nexclusiveFunction(5);\nexclusiveFunction(6);\n\n// The following will be printed:\n// exclusiveFunction(5) started\n// exclusiveFunction(5) ending\n// exclusiveFunction(6) started\n// exclusiveFunction(6) ending\n```\n\n## Types\n\n[Flow](https://flowtype.org/) type declarations for this module are included!\nIf you are using Flow, they won't require any configuration to use.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/AgentME/synchd.git"
  },
  "scripts": {
    "flow_check": "flow check",
    "lint": "eslint .",
    "lint-fix": "eslint . --fix",
    "prepublish": "babel -s inline -d js/ src/ && flow-copy-source -v src js",
    "test": "npm run lint && npm run flow_check && mocha"
  },
  "version": "1.0.2"
}
